import os
import discord
from discord.ext import commands
import requests
from bs4 import BeautifulSoup
import shodan
import re
from datetime import datetime, timedelta
import csv
import io
import nmap
import asyncio
import ipaddress
import aiohttp
import hashlib
import sys
import importlib.util

# Importer le fichier de configuration
try:
    spec = importlib.util.spec_from_file_location("config", "config.py")
    config = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(config)
except Exception as e:
    print(f"Erreur lors du chargement de config.py: {e}")
    config = None

class Exploiter(commands.Cog):
    """Cog for ExploiterBot functionality - CVE lookup, exploit search, and server scanning"""
    
    def __init__(self, bot):
        self.bot = bot
        
        # Récupérer les clés API depuis config.py ou les variables d'environnement
        if config and hasattr(config, 'SHODAN_API_KEY'):
            self.shodan_api_key = config.SHODAN_API_KEY
            print("🔑 Clé API Shodan chargée depuis config.py")
        else:
            self.shodan_api_key = os.getenv('SHODAN_API_KEY')
            print("🔑 Clé API Shodan chargée depuis les variables d'environnement")
            
        if config and hasattr(config, 'VIRUSTOTAL_API_KEY'):
            self.virustotal_api_key = config.VIRUSTOTAL_API_KEY
            print("🔑 Clé API VirusTotal chargée depuis config.py")
        else:
            self.virustotal_api_key = os.getenv('VIRUSTOTAL_API_KEY')
            print("🔑 Clé API VirusTotal chargée depuis les variables d'environnement")
            
        if config and hasattr(config, 'IPINFO_API_KEY'):
            self.ipinfo_api_key = config.IPINFO_API_KEY
            print("🔑 Clé API IPInfo chargée depuis config.py")
        else:
            self.ipinfo_api_key = os.getenv('IPINFO_API_KEY')
            print("🔑 Clé API IPInfo chargée depuis les variables d'environnement")
            
        self.shodan_api = shodan.Shodan(self.shodan_api_key) if self.shodan_api_key else None
        self.exploit_db_url = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
        self.cached_exploits = None
        self.last_cache_update = None
        self.last_cve_check = None
        self.seen_cves = set()  # Pour stocker les CVEs déjà vues
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        self.nm = nmap.PortScanner()
        self.alert_channel_id = int(os.getenv('ALERT_CHANNEL_ID', 0))
        
        # Start CVE monitoring task
        self.cve_monitor_task = self.bot.loop.create_task(self.monitor_new_cves())
        
        # Liste des fournisseurs de Cloud connus
        self.cloud_providers = {
            "Amazon": ["AWS", "Amazon Web Services", "Amazon"],
            "Google": ["Google Cloud", "GCP", "Google"],
            "Microsoft": ["Azure", "Microsoft Corporation"],
            "OVH": ["OVH", "OVHcloud"],
            "DigitalOcean": ["DigitalOcean"],
            "Linode": ["Linode"],
            "Vultr": ["Vultr"],
            "Heroku": ["Heroku"],
            "IBM": ["IBM Cloud", "Softlayer"],
            "Oracle": ["Oracle Cloud", "Oracle Corporation"],
            "Alibaba": ["Alibaba Cloud", "Aliyun"]
        }
        
        # Liste des indices de VPN / Proxy
        self.vpn_proxy_indicators = [
            "vpn", "proxy", "tor", "exit node", "anonymous", "anonymizing", "privacy", 
            "private internet access", "nordvpn", "expressvpn", "protonvpn", "cyberghost",
            "surfshark", "mullvad", "ipvanish", "torguard", "hide my ip", "cryptostorm",
            "airvpn", "purevpn", "tunnelbear"
        ]
        
        # Dictionnaire des recommandations par port
        self.port_recommendations = {
            21: {
                "service": "FTP",
                "risks": [
                    "🔥 Ce serveur FTP pourrait être vulnérable à une attaque brute-force",
                    "🔥 Vérifiez si l'accès anonyme est activé (user: anonymous, pass: anonymous)",
                    "🔥 Les anciennes versions de FTP peuvent avoir des vulnérabilités de type buffer overflow"
                ],
                "recommendations": [
                    "🔗 Essayez un bruteforce avec Hydra : `hydra -L users.txt -P pass.txt ftp://[IP]`",
                    "🔗 Testez l'accès anonyme : `ftp [IP]` puis utilisez 'anonymous' comme login",
                    "🔗 Scannez les vulnérabilités avec : `nmap --script=ftp-* -p 21 [IP]`"
                ]
            },
            22: {
                "service": "SSH",
                "risks": [
                    "🔥 Si l'authentification par mot de passe est activée, le serveur est vulnérable au bruteforce",
                    "🔥 Les anciennes versions d'OpenSSH peuvent avoir des vulnérabilités RCE"
                ],
                "recommendations": [
                    "🔗 Bruteforce avec Hydra : `hydra -L users.txt -P pass.txt ssh://[IP]`",
                    "🔗 Énumération des utilisateurs : `nmap -p 22 --script ssh-enum-auth [IP]`",
                    "🔗 Vérifiez la version avec : `nc -vn [IP] 22`"
                ]
            },
            23: {
                "service": "Telnet",
                "risks": [
                    "🔥 Telnet n'est pas chiffré, les données transitent en clair",
                    "🔥 Vulnérable aux attaques MITM et au sniffing"
                ],
                "recommendations": [
                    "🔗 Capture de trafic : `tcpdump -i eth0 port 23 -w telnet.pcap`",
                    "🔗 Bruteforce : `hydra -L users.txt -P pass.txt telnet://[IP]`"
                ]
            },
            25: {
                "service": "SMTP",
                "risks": [
                    "🔥 Possibilité d'énumération des utilisateurs via VRFY/EXPN",
                    "🔥 Risque de relay SMTP si mal configuré"
                ],
                "recommendations": [
                    "🔗 Énumération des utilisateurs : `nc [IP] 25` puis `VRFY root`",
                    "🔗 Test de relay : `nmap --script=smtp-open-relay -p 25 [IP]`",
                    "🔗 Scan complet : `nmap --script=smtp-* -p 25 [IP]`"
                ]
            },
            80: {
                "service": "HTTP",
                "risks": [
                    "🔥 Vulnérabilités web possibles (XSS, SQLi, RFI, etc.)",
                    "🔥 Versions obsolètes de serveurs web peuvent être vulnérables"
                ],
                "recommendations": [
                    "🔗 Scan Nikto : `nikto -h [IP]`",
                    "🔗 Énumération des répertoires : `gobuster dir -u http://[IP] -w wordlist.txt`",
                    "🔗 Scan des vulnérabilités : `nmap --script=http-vuln* -p 80 [IP]`"
                ]
            },
            443: {
                "service": "HTTPS",
                "risks": [
                    "🔥 Vérifiez les versions SSL/TLS et les certificats",
                    "🔥 Vulnérabilités possibles : Heartbleed, POODLE, etc."
                ],
                "recommendations": [
                    "🔗 Test SSL/TLS : `sslscan [IP]`",
                    "🔗 Vérification Heartbleed : `nmap -p 443 --script ssl-heartbleed [IP]`",
                    "🔗 Scan complet : `nmap --script=ssl-* -p 443 [IP]`"
                ]
            },
            3306: {
                "service": "MySQL",
                "risks": [
                    "🔥 Base de données potentiellement accessible sans mot de passe",
                    "🔥 Versions anciennes vulnérables aux injections SQL"
                ],
                "recommendations": [
                    "🔗 Test de connexion : `mysql -u root -h [IP]`",
                    "🔗 Bruteforce : `hydra -L users.txt -P pass.txt mysql://[IP]`",
                    "🔗 Scan des vulnérabilités : `nmap --script=mysql-* -p 3306 [IP]`"
                ]
            },
            3389: {
                "service": "RDP",
                "risks": [
                    "🔥 Vulnérable aux attaques par force brute",
                    "🔥 BlueKeep et autres vulnérabilités RCE sur anciennes versions"
                ],
                "recommendations": [
                    "🔗 Bruteforce : `hydra -L users.txt -P pass.txt rdp://[IP]`",
                    "🔗 Test BlueKeep : `nmap --script rdp-vuln-ms12-020 -p 3389 [IP]`"
                ]
            }
        }
        
    async def update_exploit_cache(self):
        """Update the cached exploit database"""
        try:
            print(f"Fetching exploit database from {self.exploit_db_url}")
            response = requests.get(self.exploit_db_url, headers=self.headers, timeout=30)
            print(f"Response status code: {response.status_code}")
            
            if response.status_code == 200:
                csv_data = response.content.decode('utf-8')
                reader = csv.DictReader(io.StringIO(csv_data))
                self.cached_exploits = list(reader)
                self.last_cache_update = datetime.now()
                print(f"Successfully cached {len(self.cached_exploits)} exploits")
                return True
            else:
                print(f"Failed to fetch exploit database. Status code: {response.status_code}")
                return False
                
        except requests.exceptions.Timeout:
            print("Timeout while fetching exploit database")
            return False
        except requests.exceptions.RequestException as e:
            print(f"Network error while fetching exploit database: {str(e)}")
            return False
        except Exception as e:
            print(f"Error updating exploit cache: {str(e)}")
            return False
        
    @commands.command(name="cve")
    async def cve_lookup(self, ctx, cve_id: str):
        """Look up information about a specific CVE and related exploits
        
        Usage: !cve CVE-XXXX-XXXXX
        """
        # Validate CVE ID format
        if not re.match(r"CVE-\d{4}-\d{4,7}", cve_id, re.IGNORECASE):
            await ctx.send("❌ Invalid CVE ID format. Please use the format: CVE-YYYY-NNNNN")
            return
            
        # Normalize CVE ID to uppercase
        cve_id = cve_id.upper()
        
        # Create embed for response
        embed = discord.Embed(
            title=f"🔍 CVE Lookup: {cve_id}",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        
        # Update exploit cache if needed
        if not self.cached_exploits or (datetime.now() - self.last_cache_update).days >= 1:
            loading_msg = await ctx.send("⏳ Updating exploit database... Please wait.")
            cache_updated = await self.update_exploit_cache()
            await loading_msg.delete()
            if not cache_updated:
                embed.description = "❌ Error updating exploit database. Please try again later."
                await ctx.send(embed=embed)
                return
        
        try:
            # Search for CVE in cached exploits
            exploits_found = []
            for exploit in self.cached_exploits:
                if cve_id.lower() in exploit.get('description', '').lower():
                    exploits_found.append({
                        'date': exploit.get('date', 'Unknown'),
                        'title': exploit.get('description', 'No title'),
                        'type': exploit.get('type', 'Unknown'),
                        'platform': exploit.get('platform', 'Unknown'),
                        'path': exploit.get('file', ''),
                        'id': exploit.get('id', 'Unknown')
                    })
            
            if exploits_found:
                embed.description = f"✅ Found {len(exploits_found)} exploit(s) for {cve_id} on Exploit-DB."
                
                # Get NIST NVD data
                nvd_url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
                nvd_response = requests.get(nvd_url)
                if nvd_response.status_code == 200:
                    nvd_data = nvd_response.json()
                    if 'vulnerabilities' in nvd_data and nvd_data['vulnerabilities']:
                        vuln = nvd_data['vulnerabilities'][0]['cve']
                        if 'descriptions' in vuln:
                            for desc in vuln['descriptions']:
                                if desc['lang'] == 'en':
                                    embed.add_field(
                                        name="📝 Description",
                                        value=desc['value'][:1024],
                                        inline=False
                                    )
                                    break
                        
                        if 'metrics' in vuln and 'cvssMetricV31' in vuln['metrics']:
                            cvss = vuln['metrics']['cvssMetricV31'][0]['cvssData']
                            embed.add_field(
                                name="⚠️ CVSS Score",
                                value=f"{cvss.get('baseScore', 'N/A')} ({cvss.get('baseSeverity', 'Unknown')})",
                                inline=True
                            )
                
                # Add exploit information
                for i, exploit in enumerate(exploits_found[:5]):  # Limit to 5 results
                    embed.add_field(
                        name=f"💥 Exploit {i+1}: {exploit['title'][:100]}...",
                        value=f"**Type:** {exploit['type']}\n**Platform:** {exploit['platform']}\n**Date:** {exploit['date']}\n**Link:** [View on Exploit-DB](https://www.exploit-db.com/exploits/{exploit['id']})",
                        inline=False
                    )
            else:
                # If no exploits found in Exploit-DB, still try to get NIST data
                nvd_url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
                nvd_response = requests.get(nvd_url)
                if nvd_response.status_code == 200:
                    nvd_data = nvd_response.json()
                    if 'vulnerabilities' in nvd_data and nvd_data['vulnerabilities']:
                        vuln = nvd_data['vulnerabilities'][0]['cve']
                        embed.description = f"ℹ️ No exploits found for {cve_id} on Exploit-DB, but found vulnerability information:"
                        
                        if 'descriptions' in vuln:
                            for desc in vuln['descriptions']:
                                if desc['lang'] == 'en':
                                    embed.add_field(
                                        name="📝 Description",
                                        value=desc['value'][:1024],
                                        inline=False
                                    )
                                    break
                        
                        if 'metrics' in vuln and 'cvssMetricV31' in vuln['metrics']:
                            cvss = vuln['metrics']['cvssMetricV31'][0]['cvssData']
                            embed.add_field(
                                name="⚠️ CVSS Score",
                                value=f"{cvss.get('baseScore', 'N/A')} ({cvss.get('baseSeverity', 'Unknown')})",
                                inline=True
                            )
                    else:
                        embed.description = f"ℹ️ No information found for {cve_id}"
                else:
                    embed.description = f"ℹ️ No exploits found for {cve_id} on Exploit-DB."
            
            # Add NIST NVD link for more information
            embed.add_field(
                name="📚 More Information",
                value=f"[View on NIST NVD](https://nvd.nist.gov/vuln/detail/{cve_id})",
                inline=False
            )
            
        except Exception as e:
            embed.description = f"❌ Error occurred while searching for {cve_id}: {str(e)}"
        
        # Set footer
        embed.set_footer(text=f"Requested by {ctx.author.name}", icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
        
        await ctx.send(embed=embed)
    
    @commands.command(name="exploit")
    async def exploit_search(self, ctx, software: str, version: str = None):
        """Search for exploits for a specific software version
        
        Usage: !exploit [software] [version]
        Example: !exploit apache 2.4.49
        """
        # Create embed for response
        embed = discord.Embed(
            title=f"🔍 Exploit Search: {software} {version if version else ''}",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        
        # Update exploit cache if needed
        if not self.cached_exploits or (datetime.now() - self.last_cache_update).days >= 1:
            loading_msg = await ctx.send("⏳ Updating exploit database... Please wait.")
            cache_updated = await self.update_exploit_cache()
            await loading_msg.delete()
            if not cache_updated:
                embed.description = "❌ Error updating exploit database. Please try again later."
                await ctx.send(embed=embed)
                return
        
        try:
            # Search for exploits in cached database
            search_term = software.lower()
            if version:
                search_term = f"{search_term} {version}".lower()
            
            exploits_found = []
            for exploit in self.cached_exploits:
                if search_term in exploit.get('description', '').lower():
                    exploits_found.append({
                        'date': exploit.get('date', 'Unknown'),
                        'title': exploit.get('description', 'No title'),
                        'type': exploit.get('type', 'Unknown'),
                        'platform': exploit.get('platform', 'Unknown'),
                        'path': exploit.get('file', ''),
                        'id': exploit.get('id', 'Unknown')
                    })
            
            if exploits_found:
                embed.description = f"✅ Found {len(exploits_found)} exploit(s) for {software} {version if version else ''}"
                
                for i, exploit in enumerate(exploits_found[:5]):  # Limit to 5 results
                    embed.add_field(
                        name=f"💥 Exploit {i+1}: {exploit['title'][:100]}...",
                        value=f"**Type:** {exploit['type']}\n**Platform:** {exploit['platform']}\n**Date:** {exploit['date']}\n**Link:** [View on Exploit-DB](https://www.exploit-db.com/exploits/{exploit['id']})",
                        inline=False
                    )
            else:
                embed.description = f"ℹ️ No exploits found for {software} {version if version else ''}"
            
        except Exception as e:
            embed.description = f"❌ Error occurred while searching for exploits: {str(e)}"
        
        # Set footer
        embed.set_footer(text=f"Requested by {ctx.author.name}", icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
        
        await ctx.send(embed=embed)
    
    @commands.command(name="latest")
    async def latest_exploits(self, ctx):
        """Get the 5 most recent exploits from Exploit-DB
        
        Usage: !latest
        """
        # Create embed for response
        embed = discord.Embed(
            title="🔥 Latest Exploits on Exploit-DB",
            color=discord.Color.red(),
            timestamp=datetime.now()
        )
        
        # Update exploit cache if needed
        if not self.cached_exploits or (datetime.now() - self.last_cache_update).days >= 1:
            loading_msg = await ctx.send("⏳ Updating exploit database... Please wait.")
            cache_updated = await self.update_exploit_cache()
            await loading_msg.delete()
            if not cache_updated:
                embed.description = "❌ Error updating exploit database. Please try again later."
                await ctx.send(embed=embed)
                return
        
        try:
            # Get the 5 most recent exploits
            latest_exploits = self.cached_exploits[:5]
            
            if latest_exploits:
                embed.description = f"✅ Found {len(latest_exploits)} latest exploits on Exploit-DB."
                
                for i, exploit in enumerate(latest_exploits):
                    embed.add_field(
                        name=f"💥 Exploit {i+1}: {exploit['description'][:100]}...",
                        value=f"**Type:** {exploit['type']}\n**Platform:** {exploit['platform']}\n**Date:** {exploit['date']}\n**Link:** [View on Exploit-DB](https://www.exploit-db.com/exploits/{exploit['id']})",
                        inline=False
                    )
            else:
                embed.description = "ℹ️ No exploits found on Exploit-DB."
            
        except Exception as e:
            embed.description = f"❌ Error occurred while fetching latest exploits: {str(e)}"
        
        # Set footer
        embed.set_footer(text=f"Requested by {ctx.author.name}", icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
        
        await ctx.send(embed=embed)
    
    async def is_valid_target(self, target: str) -> bool:
        """Validate if the target is a valid IP address or domain"""
        try:
            ipaddress.ip_address(target)
            return True
        except ValueError:
            # Si ce n'est pas une IP valide, vérifier si c'est un nom de domaine
            if re.match(r'^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z]{2,})+$', target):
                return True
            return False
            
    async def run_nmap_scan(self, target: str, scan_type: str = "basic"):
        """Run Nmap scan asynchronously"""
        try:
            if scan_type == "basic":
                # Scan de base : les 1000 ports les plus communs
                arguments = "-sV -sC -F"
            elif scan_type == "full":
                # Scan complet : tous les ports
                arguments = "-sV -sC -p-"
            elif scan_type == "vuln":
                # Scan de vulnérabilités
                arguments = "-sV --script vuln"
            else:
                # Scan par défaut
                arguments = "-sV -sC -F"
                
            # Exécuter le scan Nmap de manière asynchrone
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(None, self.nm.scan, target, None, arguments)
            
            return self.nm
            
        except Exception as e:
            print(f"Error during Nmap scan: {str(e)}")
            return None
            
    async def search_exploits_for_service(self, product: str, version: str = None) -> list:
        """Search for exploits related to a specific service and version"""
        exploits = []
        
        if not self.cached_exploits:
            await self.update_exploit_cache()
            
        if not self.cached_exploits:
            return exploits
            
        search_terms = [product.lower()]
        if version:
            search_terms.append(version)
            
        # Search in cached exploits
        for exploit in self.cached_exploits:
            description = exploit.get('description', '').lower()
            if all(term in description for term in search_terms):
                exploits.append({
                    'date': exploit.get('date', 'Unknown'),
                    'title': exploit.get('description', 'No title'),
                    'type': exploit.get('type', 'Unknown'),
                    'platform': exploit.get('platform', 'Unknown'),
                    'id': exploit.get('id', 'Unknown')
                })
                
        return exploits

    async def get_service_recommendations(self, port: int, service_info: dict) -> dict:
        """Get recommendations for a specific port and service"""
        recommendations = {
            "risks": [],
            "recommendations": [],
            "exploits": []
        }
        
        # Get base recommendations for the port
        if port in self.port_recommendations:
            base_recs = self.port_recommendations[port]
            recommendations["risks"].extend(base_recs["risks"])
            recommendations["recommendations"].extend(base_recs["recommendations"])
        
        # Add version-specific recommendations and search for exploits
        if service_info.get('product') and service_info.get('version'):
            product = service_info['product'].lower()
            version = service_info['version']
            
            # Search for exploits
            exploits = await self.search_exploits_for_service(product, version)
            if exploits:
                recommendations["exploits"].extend(exploits)
                recommendations["risks"].append(f"🔥 Des exploits ont été trouvés pour {product} {version}")
                
            # Version-specific checks
            if product == 'apache':
                if version.startswith('2.4.49'):
                    recommendations["risks"].append("🔥 Apache 2.4.49 est vulnérable à CVE-2021-41773 (Path Traversal & RCE)")
                    recommendations["recommendations"].append("🔗 Testez la vulnérabilité : `curl -v 'http://[IP]/cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh'`")
                
            elif product == 'openssh':
                if version.split('.')[0] < '7':
                    recommendations["risks"].append("🔥 Cette version d'OpenSSH est ancienne et potentiellement vulnérable")
                    recommendations["recommendations"].append("🔗 Recherchez des exploits : `searchsploit openssh " + version + "`")
                    recommendations["recommendations"].append("🔗 Bruteforce avec rockyou.txt : `hydra -l root -P /usr/share/wordlists/rockyou.txt ssh://[IP]`")
                
            elif product == 'mysql':
                if version.split('.')[0] < '5':
                    recommendations["risks"].append("🔥 Cette version de MySQL est obsolète et vulnérable")
                    recommendations["recommendations"].append("🔗 Testez les vulnérabilités connues : `nmap --script=mysql-vuln* -p 3306 [IP]`")
                    recommendations["recommendations"].append("🔗 Bruteforce avec wordlist : `hydra -l root -P common-passwords.txt mysql://[IP]`")
                
            elif product == 'wordpress':
                recommendations["risks"].append("🔥 WordPress détecté - Vulnérabilités possibles dans les plugins/thèmes")
                recommendations["recommendations"].append("🔗 Scan WordPress : `wpscan --url http://[IP] --enumerate p,t,u`")
                recommendations["recommendations"].append("🔗 Bruteforce admin : `wpscan --url http://[IP] --passwords /usr/share/wordlists/rockyou.txt`")
                
            elif product == 'joomla':
                recommendations["risks"].append("🔥 Joomla détecté - Vérifiez les vulnérabilités connues")
                recommendations["recommendations"].append("🔗 Scan Joomla : `joomscan -u http://[IP]`")
                
            elif product == 'drupal':
                recommendations["risks"].append("🔥 Drupal détecté - Vérifiez les vulnérabilités connues")
                recommendations["recommendations"].append("🔗 Scan Drupal : `droopescan scan drupal -u http://[IP]`")
                
        # Add web application specific recommendations
        if port in [80, 443]:
            recommendations["recommendations"].extend([
                "🔗 Énumération des répertoires : `gobuster dir -u http://[IP] -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt`",
                "🔗 Scan des vulnérabilités web : `nikto -h [IP]`",
                "🔗 Test des sous-domaines : `wfuzz -c -w /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -u http://[IP] -H 'Host: FUZZ.[domain]'`"
            ])
            
        return recommendations

    @commands.command(name="scan")
    async def scan_target(self, ctx, scan_type: str, target: str, scan_mode: str = "basic"):
        """Scan a target using various tools
        
        Usage: 
        !scan ip [IP address] [scan_mode]  - Scan with Shodan
        !scan nmap [IP/domain] [scan_mode] - Scan with Nmap (basic/full/vuln)
        """
        # Vérifier si la cible est valide
        if not await self.is_valid_target(target):
            await ctx.send("❌ Invalid target. Please provide a valid IP address or domain name.")
            return
            
        # Create embed for response
        embed = discord.Embed(
            title=f"🔍 Scan Results: {target}",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        
        # Send initial message
        message = await ctx.send(f"🔍 Scanning {target}... This may take a moment.")
        
        try:
            if scan_type.lower() == "ip":
                # Scan Shodan
                if not self.shodan_api:
                    await message.edit(content="❌ Shodan API key is not configured. Please contact the bot administrator.")
                    return
                    
                host_info = self.shodan_api.host(target)
                
                # Update embed with Shodan information
                embed.description = f"✅ Shodan scan complete for {target}"
                
                # Add basic host information
                if 'country_name' in host_info:
                    embed.add_field(
                        name="📍 Location",
                        value=f"{host_info.get('country_name', 'Unknown')}, {host_info.get('city', 'Unknown')}",
                        inline=True
                    )
                    
                if 'org' in host_info:
                    embed.add_field(
                        name="🏢 Organization",
                        value=host_info.get('org', 'Unknown'),
                        inline=True
                    )
                    
                if 'os' in host_info:
                    embed.add_field(
                        name="💻 Operating System",
                        value=host_info.get('os', 'Unknown'),
                        inline=True
                    )
                    
                # Add open ports from Shodan
                if 'ports' in host_info and host_info['ports']:
                    embed.add_field(
                        name="🔓 Open Ports (Shodan)",
                        value=", ".join(map(str, host_info['ports'][:15])) + (f" and {len(host_info['ports']) - 15} more..." if len(host_info['ports']) > 15 else ""),
                        inline=False
                    )
                
            elif scan_type.lower() == "nmap":
                # Update message
                await message.edit(content=f"🔍 Running Nmap scan on {target} ({scan_mode} mode)... This may take a while.")
                
                # Run Nmap scan
                scanner = await self.run_nmap_scan(target, scan_mode)
                
                if scanner and target in scanner.all_hosts():
                    host = scanner[target]
                    
                    # Basic host info
                    if 'hostnames' in host:
                        hostnames = ", ".join([h['name'] for h in host['hostnames']])
                        if hostnames:
                            embed.add_field(
                                name="📛 Hostnames",
                                value=hostnames,
                                inline=False
                            )
                    
                    # OS detection
                    if 'osmatch' in host:
                        os_matches = host['osmatch']
                        if os_matches:
                            best_match = os_matches[0]
                            embed.add_field(
                                name="💻 Operating System",
                                value=f"{best_match['name']} ({best_match['accuracy']}% accuracy)",
                                inline=False
                            )
                    
                    # Port information with recommendations
                    open_ports = []
                    services_info = ""
                    security_recommendations = ""
                    exploits_found = ""
                    
                    if 'tcp' in host:
                        for port, data in host['tcp'].items():
                            if data['state'] == 'open':
                                open_ports.append(str(port))
                                
                                # Service info
                                service_info = f"**Port {port}** ({data['name']})\n"
                                if 'product' in data:
                                    service_info += f"Product: {data['product']}\n"
                                if 'version' in data:
                                    service_info += f"Version: {data['version']}\n"
                                services_info += service_info + "\n"
                                
                                # Get recommendations and exploits
                                recs = await self.get_service_recommendations(port, data)
                                
                                # Add security recommendations
                                if recs["risks"] or recs["recommendations"]:
                                    security_recommendations += f"\n**Port {port} ({data['name']}):**\n"
                                    if recs["risks"]:
                                        security_recommendations += "**Risques détectés:**\n"
                                        security_recommendations += "\n".join(recs["risks"]) + "\n"
                                    if recs["recommendations"]:
                                        security_recommendations += "**Recommandations:**\n"
                                        security_recommendations += "\n".join(recs["recommendations"]) + "\n"
                                
                                # Add exploits if found
                                if recs["exploits"]:
                                    exploits_found += f"\n**🎯 Exploits pour {data['name']} ({data.get('product', '')} {data.get('version', '')}):**\n"
                                    for exploit in recs["exploits"][:3]:  # Limit to 3 exploits per service
                                        exploits_found += f"• {exploit['title']}\n"
                                        exploits_found += f"  Type: {exploit['type']} | Platform: {exploit['platform']} | Date: {exploit['date']}\n"
                                        exploits_found += f"  🔗 [Voir sur Exploit-DB](https://www.exploit-db.com/exploits/{exploit['id']})\n\n"
                    
                    if open_ports:
                        embed.add_field(
                            name="🔓 Open Ports (Nmap)",
                            value=", ".join(open_ports),
                            inline=False
                        )
                    
                    if services_info:
                        embed.add_field(
                            name="🔧 Services Detected",
                            value=services_info[:1024],
                            inline=False
                        )
                    
                    if exploits_found:
                        # Split exploits into chunks of 1024 characters
                        chunks = [exploits_found[i:i + 1024] for i in range(0, len(exploits_found), 1024)]
                        for i, chunk in enumerate(chunks):
                            embed.add_field(
                                name=f"💥 Available Exploits (Part {i+1})" if i > 0 else "💥 Available Exploits",
                                value=chunk,
                                inline=False
                            )
                    
                    if security_recommendations:
                        # Split recommendations into chunks of 1024 characters
                        chunks = [security_recommendations[i:i + 1024] for i in range(0, len(security_recommendations), 1024)]
                        for i, chunk in enumerate(chunks):
                            embed.add_field(
                                name=f"🛡️ Security Recommendations (Part {i+1})" if i > 0 else "🛡️ Security Recommendations",
                                value=chunk,
                                inline=False
                            )
                    
                    if exploits_found or security_recommendations:
                        embed.color = discord.Color.red()
                    
                    embed.description = f"✅ Nmap scan complete for {target} ({scan_mode} mode)"
                else:
                    embed.description = f"❌ No results from Nmap scan for {target}"
            
            else:
                await message.edit(content="❌ Invalid scan type. Use 'ip' for Shodan scan or 'nmap' for Nmap scan.")
                return
            
        except Exception as e:
            embed.description = f"❌ Error occurred while scanning {target}: {str(e)}"
            embed.color = discord.Color.red()
        
        # Set footer
        embed.set_footer(text=f"Requested by {ctx.author.name}", icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
        
        # Edit the initial message with the embed
        await message.edit(content=None, embed=embed)

    async def analyze_file(self, file_url: str, filename: str) -> dict:
        """Analyze a file using VirusTotal API"""
        if not self.virustotal_api_key:
            return {"error": "VirusTotal API key not configured"}
            
        try:
            # Download the file
            async with aiohttp.ClientSession() as session:
                async with session.get(file_url) as response:
                    if response.status != 200:
                        return {"error": "Failed to download file"}
                    file_content = await response.read()
            
            # Calculate SHA256 hash
            sha256_hash = hashlib.sha256(file_content).hexdigest()
            
            # Check if the file has been previously scanned
            headers = {
                "accept": "application/json",
                "x-apikey": self.virustotal_api_key
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(f"https://www.virustotal.com/api/v3/files/{sha256_hash}", headers=headers) as response:
                    if response.status == 200:
                        result = await response.json()
                        return {
                            "found": True,
                            "data": result.get("data", {}),
                            "sha256": sha256_hash
                        }
                    elif response.status == 404:
                        # File hasn't been scanned before, upload it
                        url = "https://www.virustotal.com/api/v3/files"
                        
                        # Get upload URL
                        async with session.get("https://www.virustotal.com/api/v3/files/upload_url", headers=headers) as response:
                            if response.status != 200:
                                return {"error": "Failed to get upload URL"}
                            upload_url = (await response.json())["data"]
                        
                        # Upload file
                        files = {"file": (filename, file_content)}
                        async with session.post(upload_url, headers=headers, data=files) as response:
                            if response.status != 200:
                                return {"error": "Failed to upload file"}
                            upload_result = await response.json()
                            
                        # Get analysis results
                        analysis_id = upload_result["data"]["id"]
                        max_attempts = 10
                        attempts = 0
                        
                        while attempts < max_attempts:
                            async with session.get(f"https://www.virustotal.com/api/v3/analyses/{analysis_id}", headers=headers) as response:
                                if response.status == 200:
                                    result = await response.json()
                                    if result["data"]["attributes"]["status"] == "completed":
                                        return {
                                            "found": True,
                                            "data": result["data"],
                                            "sha256": sha256_hash
                                        }
                            attempts += 1
                            await asyncio.sleep(15)  # Wait between attempts
                            
                        return {"error": "Analysis timed out"}
                    else:
                        return {"error": f"VirusTotal API error: {response.status}"}
                        
        except Exception as e:
            return {"error": f"Error analyzing file: {str(e)}"}

    @commands.Cog.listener()
    async def on_message(self, message):
        """Listen for file attachments and analyze them"""
        if message.author.bot:
            return
            
        if not message.attachments:
            return
            
        for attachment in message.attachments:
            # Skip non-suspicious file types
            if any(attachment.filename.lower().endswith(ext) for ext in ['.jpg', '.png', '.gif', '.mp4', '.mp3', '.wav']):
                continue
                
            # Analyze the file
            loading_msg = await message.channel.send(f"🔍 Analyzing file: {attachment.filename}...")
            
            result = await self.analyze_file(attachment.url, attachment.filename)
            
            if "error" in result:
                await loading_msg.edit(content=f"❌ Error analyzing file: {result['error']}")
                continue
                
            # Create embed for results
            embed = discord.Embed(
                title=f"🔍 File Analysis: {attachment.filename}",
                color=discord.Color.blue(),
                timestamp=datetime.now()
            )
            
            if result["found"]:
                data = result["data"]
                attributes = data.get("attributes", {})
                stats = attributes.get("stats", {})
                
                # Add basic info
                embed.add_field(
                    name="📊 Analysis Results",
                    value=f"Malicious: {stats.get('malicious', 0)}\n"
                          f"Suspicious: {stats.get('suspicious', 0)}\n"
                          f"Harmless: {stats.get('harmless', 0)}",
                    inline=False
                )
                
                embed.add_field(
                    name="🔒 File Hash (SHA256)",
                    value=f"`{result['sha256']}`",
                    inline=False
                )
                
                # Add link to full report
                embed.add_field(
                    name="📝 Full Report",
                    value=f"[View on VirusTotal](https://www.virustotal.com/gui/file/{result['sha256']})",
                    inline=False
                )
                
                # Set color based on results
                if stats.get('malicious', 0) > 0:
                    embed.color = discord.Color.red()
                    
                    # Send alert to dedicated channel if file is malicious
                    if self.alert_channel_id:
                        alert_channel = self.bot.get_channel(self.alert_channel_id)
                        if alert_channel:
                            alert_embed = discord.Embed(
                                title="⚠️ Malicious File Detected!",
                                description=f"A malicious file was uploaded in {message.channel.mention}",
                                color=discord.Color.red(),
                                timestamp=datetime.now()
                            )
                            alert_embed.add_field(
                                name="File Information",
                                value=f"Name: {attachment.filename}\n"
                                      f"Uploader: {message.author.mention}\n"
                                      f"Detections: {stats.get('malicious', 0)} / {sum(stats.values())}",
                                inline=False
                            )
                            await alert_channel.send(embed=alert_embed)
                elif stats.get('suspicious', 0) > 0:
                    embed.color = discord.Color.orange()
                else:
                    embed.color = discord.Color.green()
            
            # Set footer
            embed.set_footer(text=f"Requested by {message.author.name}", icon_url=message.author.avatar.url if message.author.avatar else None)
            
            # Edit the loading message with results
            await loading_msg.edit(content=None, embed=embed)

    async def monitor_new_cves(self):
        """Monitor for new critical CVEs"""
        await self.bot.wait_until_ready()
        
        # Get alert channel
        if not self.alert_channel_id:
            print("No alert channel configured for CVE monitoring")
            return
            
        alert_channel = self.bot.get_channel(self.alert_channel_id)
        if not alert_channel:
            print(f"Could not find alert channel with ID {self.alert_channel_id}")
            return
            
        # Send initial message with last 5 critical CVEs
        try:
            # Get CVEs from the last 7 days
            current_time = datetime.now()
            start_date = (current_time - timedelta(days=7)).strftime("%Y-%m-%dT%H:00:00.000")
            
            url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            params = {
                "pubStartDate": start_date,
                "cvssV3Severity": "CRITICAL",  # Only get critical vulnerabilities
                "resultsPerPage": 5  # Limit to 5 results
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        if data.get("vulnerabilities"):
                            await alert_channel.send("🔍 **Dernières CVE critiques détectées :**")
                            
                            # Store the IDs of CVEs we've seen
                            self.seen_cves = set()
                            
                            for vuln in data["vulnerabilities"]:
                                cve = vuln["cve"]
                                cve_id = cve.get('id')
                                self.seen_cves.add(cve_id)
                                
                                # Create embed for the CVE
                                embed = discord.Embed(
                                    title=f"⚠️ CVE Critique : {cve_id}",
                                    color=discord.Color.red(),
                                    timestamp=datetime.now()
                                )
                                
                                # Add description
                                if "descriptions" in cve:
                                    for desc in cve["descriptions"]:
                                        if desc["lang"] == "en":
                                            embed.description = desc["value"]
                                            break
                                
                                # Add CVSS score
                                if "metrics" in cve and "cvssMetricV31" in cve["metrics"]:
                                    cvss = cve["metrics"]["cvssMetricV31"][0]["cvssData"]
                                    embed.add_field(
                                        name="⚠️ CVSS Score",
                                        value=f"{cvss.get('baseScore', 'N/A')} ({cvss.get('baseSeverity', 'Unknown')})",
                                        inline=True
                                    )
                                
                                # Add references
                                if "references" in cve:
                                    refs = "\n".join([f"• [{ref.get('source')}]({ref.get('url')})" for ref in cve["references"][:5]])
                                    if refs:
                                        embed.add_field(
                                            name="📚 References",
                                            value=refs,
                                            inline=False
                                        )
                                
                                # Add NVD link
                                embed.add_field(
                                    name="🔗 More Information",
                                    value=f"[View on NVD](https://nvd.nist.gov/vuln/detail/{cve_id})",
                                    inline=False
                                )
                                
                                await alert_channel.send(embed=embed)
                            
                            await alert_channel.send("⚡ La surveillance des nouvelles CVE est maintenant active. Je vous alerterai dès qu'une nouvelle CVE critique sera publiée.")
        
        except Exception as e:
            print(f"Error fetching initial CVEs: {str(e)}")
        
        # Start monitoring loop
        while not self.bot.is_closed():
            try:
                # Get current time
                current_time = datetime.now()
                
                # Check for new CVEs every hour
                if not self.last_cve_check or (current_time - self.last_cve_check).total_seconds() > 3600:
                    # Get CVEs from the last hour
                    start_date = (current_time - timedelta(hours=1)).strftime("%Y-%m-%dT%H:00:00.000")
                    
                    # Query NVD API
                    url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
                    params = {
                        "pubStartDate": start_date,
                        "cvssV3Severity": "CRITICAL"  # Only get critical vulnerabilities
                    }
                    
                    async with aiohttp.ClientSession() as session:
                        async with session.get(url, params=params) as response:
                            if response.status == 200:
                                data = await response.json()
                                
                                if data.get("vulnerabilities"):
                                    for vuln in data["vulnerabilities"]:
                                        cve = vuln["cve"]
                                        cve_id = cve.get('id')
                                        
                                        # Only alert for CVEs we haven't seen before
                                        if cve_id not in self.seen_cves:
                                            self.seen_cves.add(cve_id)
                                            
                                            # Create embed for the CVE
                                            embed = discord.Embed(
                                                title=f"⚠️ Nouvelle CVE Critique Détectée : {cve_id}",
                                                color=discord.Color.red(),
                                                timestamp=datetime.now()
                                            )
                                            
                                            # Add description
                                            if "descriptions" in cve:
                                                for desc in cve["descriptions"]:
                                                    if desc["lang"] == "en":
                                                        embed.description = desc["value"]
                                                        break
                                            
                                            # Add CVSS score
                                            if "metrics" in cve and "cvssMetricV31" in cve["metrics"]:
                                                cvss = cve["metrics"]["cvssMetricV31"][0]["cvssData"]
                                                embed.add_field(
                                                    name="⚠️ CVSS Score",
                                                    value=f"{cvss.get('baseScore', 'N/A')} ({cvss.get('baseSeverity', 'Unknown')})",
                                                    inline=True
                                                )
                                            
                                            # Add references
                                            if "references" in cve:
                                                refs = "\n".join([f"• [{ref.get('source')}]({ref.get('url')})" for ref in cve["references"][:5]])
                                                if refs:
                                                    embed.add_field(
                                                        name="📚 References",
                                                        value=refs,
                                                        inline=False
                                                    )
                                            
                                            # Add NVD link
                                            embed.add_field(
                                                name="🔗 More Information",
                                                value=f"[View on NVD](https://nvd.nist.gov/vuln/detail/{cve_id})",
                                                inline=False
                                            )
                                            
                                            # Send alert
                                            await alert_channel.send(
                                                content="@everyone ⚠️ Nouvelle vulnérabilité critique détectée !",
                                                embed=embed
                                            )
                    
                    self.last_cve_check = current_time
            
            except Exception as e:
                print(f"Error monitoring CVEs: {str(e)}")
            
            # Wait for 1 hour before next check
            await asyncio.sleep(3600)

    def cog_unload(self):
        """Clean up tasks when cog is unloaded"""
        if hasattr(self, 'cve_monitor_task'):
            self.cve_monitor_task.cancel()

    async def get_ipinfo_data(self, ip: str) -> dict:
        """Get information about an IP address from IPinfo.io API"""
        if not self.ipinfo_api_key:
            return {"error": "IPinfo API key not configured"}
            
        try:
            url = f"https://ipinfo.io/{ip}/json?token={self.ipinfo_api_key}"
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as response:
                    if response.status == 200:
                        return await response.json()
                    else:
                        return {"error": f"IPinfo API error: {response.status}"}
        except Exception as e:
            return {"error": f"Error retrieving IP information: {str(e)}"}
            
    def detect_cloud_provider(self, org: str) -> str:
        """Detect if the organization is a cloud provider"""
        org_lower = org.lower()
        detected_providers = []
        
        for provider, keywords in self.cloud_providers.items():
            for keyword in keywords:
                if keyword.lower() in org_lower:
                    detected_providers.append(provider)
                    break
        
        if detected_providers:
            return ", ".join(detected_providers)
        return None
        
    def detect_vpn_proxy(self, org: str, hostname: str) -> bool:
        """Detect if the IP might be a VPN/Proxy/Tor node"""
        text_to_check = (org + " " + hostname).lower()
        
        for indicator in self.vpn_proxy_indicators:
            if indicator in text_to_check:
                return True
                
        return False
    
    @commands.command(name="ipinfo")
    async def ip_info(self, ctx, ip: str):
        """Get detailed information about an IP address using IPinfo.io
        
        Usage: !ipinfo [IP address]
        Example: !ipinfo 8.8.8.8
        """
        # Validate IP address format
        try:
            ipaddress.ip_address(ip)
        except ValueError:
            await ctx.send("❌ Invalid IP address format. Please provide a valid IPv4 or IPv6 address.")
            return
        
        # Create embed for response
        embed = discord.Embed(
            title=f"🔍 IP Information: {ip}",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        
        # Send initial message
        message = await ctx.send(f"🔍 Looking up information for {ip}... Please wait.")
        
        try:
            # Get IP information from IPinfo
            ipinfo_data = await self.get_ipinfo_data(ip)
            
            if "error" in ipinfo_data:
                embed.description = f"❌ {ipinfo_data['error']}"
                embed.color = discord.Color.red()
            else:
                embed.description = f"✅ IP information for {ip}"
                
                # Add location information
                location_parts = []
                if "city" in ipinfo_data:
                    location_parts.append(ipinfo_data["city"])
                if "region" in ipinfo_data:
                    location_parts.append(ipinfo_data["region"])
                if "country" in ipinfo_data:
                    location_parts.append(ipinfo_data["country"])
                
                if location_parts:
                    embed.add_field(
                        name="📍 Location",
                        value=", ".join(location_parts),
                        inline=True
                    )
                
                # Add network information
                if "org" in ipinfo_data:
                    embed.add_field(
                        name="🏢 Organization",
                        value=ipinfo_data["org"],
                        inline=True
                    )
                
                if "hostname" in ipinfo_data:
                    embed.add_field(
                        name="🌐 Hostname",
                        value=ipinfo_data["hostname"],
                        inline=True
                    )
                
                # Add ASN information
                if "asn" in ipinfo_data:
                    embed.add_field(
                        name="🔢 ASN",
                        value=ipinfo_data["asn"],
                        inline=True
                    )
                
                # Add ISP information
                if "org" in ipinfo_data:
                    embed.add_field(
                        name="🌐 ISP",
                        value=ipinfo_data["org"],
                        inline=True
                    )
                
                # Check for cloud provider
                if "org" in ipinfo_data:
                    cloud_provider = self.detect_cloud_provider(ipinfo_data["org"])
                    if cloud_provider:
                        embed.add_field(
                            name="☁️ Cloud Provider",
                            value=cloud_provider,
                            inline=True
                        )
                
                # Check for VPN/Proxy
                if "org" in ipinfo_data and "hostname" in ipinfo_data:
                    is_vpn_proxy = self.detect_vpn_proxy(
                        ipinfo_data["org"], 
                        ipinfo_data.get("hostname", "")
                    )
                    if is_vpn_proxy:
                        embed.add_field(
                            name="🏴 VPN/Proxy Detection",
                            value="⚠️ This IP appears to be a VPN, Proxy, or Tor exit node",
                            inline=False
                        )
                        embed.color = discord.Color.orange()
                
                # Add abuse contact
                if "abuse" in ipinfo_data:
                    abuse_info = []
                    if "email" in ipinfo_data["abuse"]:
                        abuse_info.append(f"Email: {ipinfo_data['abuse']['email']}")
                    if "phone" in ipinfo_data["abuse"]:
                        abuse_info.append(f"Phone: {ipinfo_data['abuse']['phone']}")
                    
                    if abuse_info:
                        embed.add_field(
                            name="📧 Abuse Contact",
                            value="\n".join(abuse_info),
                            inline=False
                        )
                
                # Add threat intelligence section with option to run more scans
                embed.add_field(
                    name="🔒 Threat Intelligence",
                    value="Use `!scan nmap " + ip + " [mode]` to scan for open ports and vulnerabilities\n"
                         "Use `!scan ip " + ip + "` to get information from Shodan",
                    inline=False
                )
            
        except Exception as e:
            embed.description = f"❌ Error occurred while retrieving information for {ip}: {str(e)}"
            embed.color = discord.Color.red()
        
        # Set footer
        embed.set_footer(text=f"Requested by {ctx.author.name}", icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
        
        # Edit the initial message with the embed
        await message.edit(content=None, embed=embed)

async def setup(bot):
    await bot.add_cog(Exploiter(bot)) 