import os
import discord
from discord.ext import commands
import requests
from bs4 import BeautifulSoup
import shodan
import re
from datetime import datetime, timedelta
import csv
import io
import nmap
import asyncio
import ipaddress
import aiohttp
import hashlib
import sys
import importlib.util

# Importer le fichier de configuration
try:
    spec = importlib.util.spec_from_file_location("config", "config.py")
    config = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(config)
except Exception as e:
    print(f"Erreur lors du chargement de config.py: {e}")
    config = None

class Exploiter(commands.Cog):
    """Cog for ExploiterBot functionality - CVE lookup, exploit search, and server scanning"""
    
    def __init__(self, bot):
        self.bot = bot
        
        # R√©cup√©rer les cl√©s API depuis config.py ou les variables d'environnement
        if config and hasattr(config, 'SHODAN_API_KEY'):
            self.shodan_api_key = config.SHODAN_API_KEY
            print("üîë Cl√© API Shodan charg√©e depuis config.py")
        else:
            self.shodan_api_key = os.getenv('SHODAN_API_KEY')
            print("üîë Cl√© API Shodan charg√©e depuis les variables d'environnement")
            
        if config and hasattr(config, 'VIRUSTOTAL_API_KEY'):
            self.virustotal_api_key = config.VIRUSTOTAL_API_KEY
            print("üîë Cl√© API VirusTotal charg√©e depuis config.py")
        else:
            self.virustotal_api_key = os.getenv('VIRUSTOTAL_API_KEY')
            print("üîë Cl√© API VirusTotal charg√©e depuis les variables d'environnement")
            
        if config and hasattr(config, 'IPINFO_API_KEY'):
            self.ipinfo_api_key = config.IPINFO_API_KEY
            print("üîë Cl√© API IPInfo charg√©e depuis config.py")
        else:
            self.ipinfo_api_key = os.getenv('IPINFO_API_KEY')
            print("üîë Cl√© API IPInfo charg√©e depuis les variables d'environnement")
            
        self.shodan_api = shodan.Shodan(self.shodan_api_key) if self.shodan_api_key else None
        self.exploit_db_url = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
        self.cached_exploits = None
        self.last_cache_update = None
        self.last_cve_check = None
        self.seen_cves = set()  # Pour stocker les CVEs d√©j√† vues
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        self.nm = nmap.PortScanner()
        self.alert_channel_id = int(os.getenv('ALERT_CHANNEL_ID', 0))
        
        # Start CVE monitoring task
        self.cve_monitor_task = self.bot.loop.create_task(self.monitor_new_cves())
        
        # Liste des fournisseurs de Cloud connus
        self.cloud_providers = {
            "Amazon": ["AWS", "Amazon Web Services", "Amazon"],
            "Google": ["Google Cloud", "GCP", "Google"],
            "Microsoft": ["Azure", "Microsoft Corporation"],
            "OVH": ["OVH", "OVHcloud"],
            "DigitalOcean": ["DigitalOcean"],
            "Linode": ["Linode"],
            "Vultr": ["Vultr"],
            "Heroku": ["Heroku"],
            "IBM": ["IBM Cloud", "Softlayer"],
            "Oracle": ["Oracle Cloud", "Oracle Corporation"],
            "Alibaba": ["Alibaba Cloud", "Aliyun"]
        }
        
        # Liste des indices de VPN / Proxy
        self.vpn_proxy_indicators = [
            "vpn", "proxy", "tor", "exit node", "anonymous", "anonymizing", "privacy", 
            "private internet access", "nordvpn", "expressvpn", "protonvpn", "cyberghost",
            "surfshark", "mullvad", "ipvanish", "torguard", "hide my ip", "cryptostorm",
            "airvpn", "purevpn", "tunnelbear"
        ]
        
        # Dictionnaire des recommandations par port
        self.port_recommendations = {
            21: {
                "service": "FTP",
                "risks": [
                    "üî• Ce serveur FTP pourrait √™tre vuln√©rable √† une attaque brute-force",
                    "üî• V√©rifiez si l'acc√®s anonyme est activ√© (user: anonymous, pass: anonymous)",
                    "üî• Les anciennes versions de FTP peuvent avoir des vuln√©rabilit√©s de type buffer overflow"
                ],
                "recommendations": [
                    "üîó Essayez un bruteforce avec Hydra : `hydra -L users.txt -P pass.txt ftp://[IP]`",
                    "üîó Testez l'acc√®s anonyme : `ftp [IP]` puis utilisez 'anonymous' comme login",
                    "üîó Scannez les vuln√©rabilit√©s avec : `nmap --script=ftp-* -p 21 [IP]`"
                ]
            },
            22: {
                "service": "SSH",
                "risks": [
                    "üî• Si l'authentification par mot de passe est activ√©e, le serveur est vuln√©rable au bruteforce",
                    "üî• Les anciennes versions d'OpenSSH peuvent avoir des vuln√©rabilit√©s RCE"
                ],
                "recommendations": [
                    "üîó Bruteforce avec Hydra : `hydra -L users.txt -P pass.txt ssh://[IP]`",
                    "üîó √ânum√©ration des utilisateurs : `nmap -p 22 --script ssh-enum-auth [IP]`",
                    "üîó V√©rifiez la version avec : `nc -vn [IP] 22`"
                ]
            },
            23: {
                "service": "Telnet",
                "risks": [
                    "üî• Telnet n'est pas chiffr√©, les donn√©es transitent en clair",
                    "üî• Vuln√©rable aux attaques MITM et au sniffing"
                ],
                "recommendations": [
                    "üîó Capture de trafic : `tcpdump -i eth0 port 23 -w telnet.pcap`",
                    "üîó Bruteforce : `hydra -L users.txt -P pass.txt telnet://[IP]`"
                ]
            },
            25: {
                "service": "SMTP",
                "risks": [
                    "üî• Possibilit√© d'√©num√©ration des utilisateurs via VRFY/EXPN",
                    "üî• Risque de relay SMTP si mal configur√©"
                ],
                "recommendations": [
                    "üîó √ânum√©ration des utilisateurs : `nc [IP] 25` puis `VRFY root`",
                    "üîó Test de relay : `nmap --script=smtp-open-relay -p 25 [IP]`",
                    "üîó Scan complet : `nmap --script=smtp-* -p 25 [IP]`"
                ]
            },
            80: {
                "service": "HTTP",
                "risks": [
                    "üî• Vuln√©rabilit√©s web possibles (XSS, SQLi, RFI, etc.)",
                    "üî• Versions obsol√®tes de serveurs web peuvent √™tre vuln√©rables"
                ],
                "recommendations": [
                    "üîó Scan Nikto : `nikto -h [IP]`",
                    "üîó √ânum√©ration des r√©pertoires : `gobuster dir -u http://[IP] -w wordlist.txt`",
                    "üîó Scan des vuln√©rabilit√©s : `nmap --script=http-vuln* -p 80 [IP]`"
                ]
            },
            443: {
                "service": "HTTPS",
                "risks": [
                    "üî• V√©rifiez les versions SSL/TLS et les certificats",
                    "üî• Vuln√©rabilit√©s possibles : Heartbleed, POODLE, etc."
                ],
                "recommendations": [
                    "üîó Test SSL/TLS : `sslscan [IP]`",
                    "üîó V√©rification Heartbleed : `nmap -p 443 --script ssl-heartbleed [IP]`",
                    "üîó Scan complet : `nmap --script=ssl-* -p 443 [IP]`"
                ]
            },
            3306: {
                "service": "MySQL",
                "risks": [
                    "üî• Base de donn√©es potentiellement accessible sans mot de passe",
                    "üî• Versions anciennes vuln√©rables aux injections SQL"
                ],
                "recommendations": [
                    "üîó Test de connexion : `mysql -u root -h [IP]`",
                    "üîó Bruteforce : `hydra -L users.txt -P pass.txt mysql://[IP]`",
                    "üîó Scan des vuln√©rabilit√©s : `nmap --script=mysql-* -p 3306 [IP]`"
                ]
            },
            3389: {
                "service": "RDP",
                "risks": [
                    "üî• Vuln√©rable aux attaques par force brute",
                    "üî• BlueKeep et autres vuln√©rabilit√©s RCE sur anciennes versions"
                ],
                "recommendations": [
                    "üîó Bruteforce : `hydra -L users.txt -P pass.txt rdp://[IP]`",
                    "üîó Test BlueKeep : `nmap --script rdp-vuln-ms12-020 -p 3389 [IP]`"
                ]
            }
        }
        
    async def update_exploit_cache(self):
        """Update the cached exploit database"""
        try:
            print(f"Fetching exploit database from {self.exploit_db_url}")
            response = requests.get(self.exploit_db_url, headers=self.headers, timeout=30)
            print(f"Response status code: {response.status_code}")
            
            if response.status_code == 200:
                csv_data = response.content.decode('utf-8')
                reader = csv.DictReader(io.StringIO(csv_data))
                self.cached_exploits = list(reader)
                self.last_cache_update = datetime.now()
                print(f"Successfully cached {len(self.cached_exploits)} exploits")
                return True
            else:
                print(f"Failed to fetch exploit database. Status code: {response.status_code}")
                return False
                
        except requests.exceptions.Timeout:
            print("Timeout while fetching exploit database")
            return False
        except requests.exceptions.RequestException as e:
            print(f"Network error while fetching exploit database: {str(e)}")
            return False
        except Exception as e:
            print(f"Error updating exploit cache: {str(e)}")
            return False
        
    @commands.command(name="cve")
    async def cve_lookup(self, ctx, cve_id: str):
        """Look up information about a specific CVE and related exploits
        
        Usage: !cve CVE-XXXX-XXXXX
        """
        # Validate CVE ID format
        if not re.match(r"CVE-\d{4}-\d{4,7}", cve_id, re.IGNORECASE):
            await ctx.send("‚ùå Invalid CVE ID format. Please use the format: CVE-YYYY-NNNNN")
            return
            
        # Normalize CVE ID to uppercase
        cve_id = cve_id.upper()
        
        # Create embed for response
        embed = discord.Embed(
            title=f"üîç CVE Lookup: {cve_id}",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        
        # Update exploit cache if needed
        if not self.cached_exploits or (datetime.now() - self.last_cache_update).days >= 1:
            loading_msg = await ctx.send("‚è≥ Updating exploit database... Please wait.")
            cache_updated = await self.update_exploit_cache()
            await loading_msg.delete()
            if not cache_updated:
                embed.description = "‚ùå Error updating exploit database. Please try again later."
                await ctx.send(embed=embed)
                return
        
        try:
            # Search for CVE in cached exploits
            exploits_found = []
            for exploit in self.cached_exploits:
                if cve_id.lower() in exploit.get('description', '').lower():
                    exploits_found.append({
                        'date': exploit.get('date', 'Unknown'),
                        'title': exploit.get('description', 'No title'),
                        'type': exploit.get('type', 'Unknown'),
                        'platform': exploit.get('platform', 'Unknown'),
                        'path': exploit.get('file', ''),
                        'id': exploit.get('id', 'Unknown')
                    })
            
            if exploits_found:
                embed.description = f"‚úÖ Found {len(exploits_found)} exploit(s) for {cve_id} on Exploit-DB."
                
                # Get NIST NVD data
                nvd_url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
                nvd_response = requests.get(nvd_url)
                if nvd_response.status_code == 200:
                    nvd_data = nvd_response.json()
                    if 'vulnerabilities' in nvd_data and nvd_data['vulnerabilities']:
                        vuln = nvd_data['vulnerabilities'][0]['cve']
                        if 'descriptions' in vuln:
                            for desc in vuln['descriptions']:
                                if desc['lang'] == 'en':
                                    embed.add_field(
                                        name="üìù Description",
                                        value=desc['value'][:1024],
                                        inline=False
                                    )
                                    break
                        
                        if 'metrics' in vuln and 'cvssMetricV31' in vuln['metrics']:
                            cvss = vuln['metrics']['cvssMetricV31'][0]['cvssData']
                            embed.add_field(
                                name="‚ö†Ô∏è CVSS Score",
                                value=f"{cvss.get('baseScore', 'N/A')} ({cvss.get('baseSeverity', 'Unknown')})",
                                inline=True
                            )
                
                # Add exploit information
                for i, exploit in enumerate(exploits_found[:5]):  # Limit to 5 results
                    embed.add_field(
                        name=f"üí• Exploit {i+1}: {exploit['title'][:100]}...",
                        value=f"**Type:** {exploit['type']}\n**Platform:** {exploit['platform']}\n**Date:** {exploit['date']}\n**Link:** [View on Exploit-DB](https://www.exploit-db.com/exploits/{exploit['id']})",
                        inline=False
                    )
            else:
                # If no exploits found in Exploit-DB, still try to get NIST data
                nvd_url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
                nvd_response = requests.get(nvd_url)
                if nvd_response.status_code == 200:
                    nvd_data = nvd_response.json()
                    if 'vulnerabilities' in nvd_data and nvd_data['vulnerabilities']:
                        vuln = nvd_data['vulnerabilities'][0]['cve']
                        embed.description = f"‚ÑπÔ∏è No exploits found for {cve_id} on Exploit-DB, but found vulnerability information:"
                        
                        if 'descriptions' in vuln:
                            for desc in vuln['descriptions']:
                                if desc['lang'] == 'en':
                                    embed.add_field(
                                        name="üìù Description",
                                        value=desc['value'][:1024],
                                        inline=False
                                    )
                                    break
                        
                        if 'metrics' in vuln and 'cvssMetricV31' in vuln['metrics']:
                            cvss = vuln['metrics']['cvssMetricV31'][0]['cvssData']
                            embed.add_field(
                                name="‚ö†Ô∏è CVSS Score",
                                value=f"{cvss.get('baseScore', 'N/A')} ({cvss.get('baseSeverity', 'Unknown')})",
                                inline=True
                            )
                    else:
                        embed.description = f"‚ÑπÔ∏è No information found for {cve_id}"
                else:
                    embed.description = f"‚ÑπÔ∏è No exploits found for {cve_id} on Exploit-DB."
            
            # Add NIST NVD link for more information
            embed.add_field(
                name="üìö More Information",
                value=f"[View on NIST NVD](https://nvd.nist.gov/vuln/detail/{cve_id})",
                inline=False
            )
            
        except Exception as e:
            embed.description = f"‚ùå Error occurred while searching for {cve_id}: {str(e)}"
        
        # Set footer
        embed.set_footer(text=f"Requested by {ctx.author.name}", icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
        
        await ctx.send(embed=embed)
    
    @commands.command(name="exploit")
    async def exploit_search(self, ctx, software: str, version: str = None):
        """Search for exploits for a specific software version
        
        Usage: !exploit [software] [version]
        Example: !exploit apache 2.4.49
        """
        # Create embed for response
        embed = discord.Embed(
            title=f"üîç Exploit Search: {software} {version if version else ''}",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        
        # Update exploit cache if needed
        if not self.cached_exploits or (datetime.now() - self.last_cache_update).days >= 1:
            loading_msg = await ctx.send("‚è≥ Updating exploit database... Please wait.")
            cache_updated = await self.update_exploit_cache()
            await loading_msg.delete()
            if not cache_updated:
                embed.description = "‚ùå Error updating exploit database. Please try again later."
                await ctx.send(embed=embed)
                return
        
        try:
            # Search for exploits in cached database
            search_term = software.lower()
            if version:
                search_term = f"{search_term} {version}".lower()
            
            exploits_found = []
            for exploit in self.cached_exploits:
                if search_term in exploit.get('description', '').lower():
                    exploits_found.append({
                        'date': exploit.get('date', 'Unknown'),
                        'title': exploit.get('description', 'No title'),
                        'type': exploit.get('type', 'Unknown'),
                        'platform': exploit.get('platform', 'Unknown'),
                        'path': exploit.get('file', ''),
                        'id': exploit.get('id', 'Unknown')
                    })
            
            if exploits_found:
                embed.description = f"‚úÖ Found {len(exploits_found)} exploit(s) for {software} {version if version else ''}"
                
                for i, exploit in enumerate(exploits_found[:5]):  # Limit to 5 results
                    embed.add_field(
                        name=f"üí• Exploit {i+1}: {exploit['title'][:100]}...",
                        value=f"**Type:** {exploit['type']}\n**Platform:** {exploit['platform']}\n**Date:** {exploit['date']}\n**Link:** [View on Exploit-DB](https://www.exploit-db.com/exploits/{exploit['id']})",
                        inline=False
                    )
            else:
                embed.description = f"‚ÑπÔ∏è No exploits found for {software} {version if version else ''}"
            
        except Exception as e:
            embed.description = f"‚ùå Error occurred while searching for exploits: {str(e)}"
        
        # Set footer
        embed.set_footer(text=f"Requested by {ctx.author.name}", icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
        
        await ctx.send(embed=embed)
    
    @commands.command(name="latest")
    async def latest_exploits(self, ctx):
        """Get the 5 most recent exploits from Exploit-DB
        
        Usage: !latest
        """
        # Create embed for response
        embed = discord.Embed(
            title="üî• Latest Exploits on Exploit-DB",
            color=discord.Color.red(),
            timestamp=datetime.now()
        )
        
        # Update exploit cache if needed
        if not self.cached_exploits or (datetime.now() - self.last_cache_update).days >= 1:
            loading_msg = await ctx.send("‚è≥ Updating exploit database... Please wait.")
            cache_updated = await self.update_exploit_cache()
            await loading_msg.delete()
            if not cache_updated:
                embed.description = "‚ùå Error updating exploit database. Please try again later."
                await ctx.send(embed=embed)
                return
        
        try:
            # Get the 5 most recent exploits
            latest_exploits = self.cached_exploits[:5]
            
            if latest_exploits:
                embed.description = f"‚úÖ Found {len(latest_exploits)} latest exploits on Exploit-DB."
                
                for i, exploit in enumerate(latest_exploits):
                    embed.add_field(
                        name=f"üí• Exploit {i+1}: {exploit['description'][:100]}...",
                        value=f"**Type:** {exploit['type']}\n**Platform:** {exploit['platform']}\n**Date:** {exploit['date']}\n**Link:** [View on Exploit-DB](https://www.exploit-db.com/exploits/{exploit['id']})",
                        inline=False
                    )
            else:
                embed.description = "‚ÑπÔ∏è No exploits found on Exploit-DB."
            
        except Exception as e:
            embed.description = f"‚ùå Error occurred while fetching latest exploits: {str(e)}"
        
        # Set footer
        embed.set_footer(text=f"Requested by {ctx.author.name}", icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
        
        await ctx.send(embed=embed)
    
    async def is_valid_target(self, target: str) -> bool:
        """Validate if the target is a valid IP address or domain"""
        try:
            ipaddress.ip_address(target)
            return True
        except ValueError:
            # Si ce n'est pas une IP valide, v√©rifier si c'est un nom de domaine
            if re.match(r'^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z]{2,})+$', target):
                return True
            return False
            
    async def run_nmap_scan(self, target: str, scan_type: str = "basic"):
        """Run Nmap scan asynchronously"""
        try:
            if scan_type == "basic":
                # Scan de base : les 1000 ports les plus communs
                arguments = "-sV -sC -F"
            elif scan_type == "full":
                # Scan complet : tous les ports
                arguments = "-sV -sC -p-"
            elif scan_type == "vuln":
                # Scan de vuln√©rabilit√©s
                arguments = "-sV --script vuln"
            else:
                # Scan par d√©faut
                arguments = "-sV -sC -F"
                
            # Ex√©cuter le scan Nmap de mani√®re asynchrone
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(None, self.nm.scan, target, None, arguments)
            
            return self.nm
            
        except Exception as e:
            print(f"Error during Nmap scan: {str(e)}")
            return None
            
    async def search_exploits_for_service(self, product: str, version: str = None) -> list:
        """Search for exploits related to a specific service and version"""
        exploits = []
        
        if not self.cached_exploits:
            await self.update_exploit_cache()
            
        if not self.cached_exploits:
            return exploits
            
        search_terms = [product.lower()]
        if version:
            search_terms.append(version)
            
        # Search in cached exploits
        for exploit in self.cached_exploits:
            description = exploit.get('description', '').lower()
            if all(term in description for term in search_terms):
                exploits.append({
                    'date': exploit.get('date', 'Unknown'),
                    'title': exploit.get('description', 'No title'),
                    'type': exploit.get('type', 'Unknown'),
                    'platform': exploit.get('platform', 'Unknown'),
                    'id': exploit.get('id', 'Unknown')
                })
                
        return exploits

    async def get_service_recommendations(self, port: int, service_info: dict) -> dict:
        """Get recommendations for a specific port and service"""
        recommendations = {
            "risks": [],
            "recommendations": [],
            "exploits": []
        }
        
        # Get base recommendations for the port
        if port in self.port_recommendations:
            base_recs = self.port_recommendations[port]
            recommendations["risks"].extend(base_recs["risks"])
            recommendations["recommendations"].extend(base_recs["recommendations"])
        
        # Add version-specific recommendations and search for exploits
        if service_info.get('product') and service_info.get('version'):
            product = service_info['product'].lower()
            version = service_info['version']
            
            # Search for exploits
            exploits = await self.search_exploits_for_service(product, version)
            if exploits:
                recommendations["exploits"].extend(exploits)
                recommendations["risks"].append(f"üî• Des exploits ont √©t√© trouv√©s pour {product} {version}")
                
            # Version-specific checks
            if product == 'apache':
                if version.startswith('2.4.49'):
                    recommendations["risks"].append("üî• Apache 2.4.49 est vuln√©rable √† CVE-2021-41773 (Path Traversal & RCE)")
                    recommendations["recommendations"].append("üîó Testez la vuln√©rabilit√© : `curl -v 'http://[IP]/cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh'`")
                
            elif product == 'openssh':
                if version.split('.')[0] < '7':
                    recommendations["risks"].append("üî• Cette version d'OpenSSH est ancienne et potentiellement vuln√©rable")
                    recommendations["recommendations"].append("üîó Recherchez des exploits : `searchsploit openssh " + version + "`")
                    recommendations["recommendations"].append("üîó Bruteforce avec rockyou.txt : `hydra -l root -P /usr/share/wordlists/rockyou.txt ssh://[IP]`")
                
            elif product == 'mysql':
                if version.split('.')[0] < '5':
                    recommendations["risks"].append("üî• Cette version de MySQL est obsol√®te et vuln√©rable")
                    recommendations["recommendations"].append("üîó Testez les vuln√©rabilit√©s connues : `nmap --script=mysql-vuln* -p 3306 [IP]`")
                    recommendations["recommendations"].append("üîó Bruteforce avec wordlist : `hydra -l root -P common-passwords.txt mysql://[IP]`")
                
            elif product == 'wordpress':
                recommendations["risks"].append("üî• WordPress d√©tect√© - Vuln√©rabilit√©s possibles dans les plugins/th√®mes")
                recommendations["recommendations"].append("üîó Scan WordPress : `wpscan --url http://[IP] --enumerate p,t,u`")
                recommendations["recommendations"].append("üîó Bruteforce admin : `wpscan --url http://[IP] --passwords /usr/share/wordlists/rockyou.txt`")
                
            elif product == 'joomla':
                recommendations["risks"].append("üî• Joomla d√©tect√© - V√©rifiez les vuln√©rabilit√©s connues")
                recommendations["recommendations"].append("üîó Scan Joomla : `joomscan -u http://[IP]`")
                
            elif product == 'drupal':
                recommendations["risks"].append("üî• Drupal d√©tect√© - V√©rifiez les vuln√©rabilit√©s connues")
                recommendations["recommendations"].append("üîó Scan Drupal : `droopescan scan drupal -u http://[IP]`")
                
        # Add web application specific recommendations
        if port in [80, 443]:
            recommendations["recommendations"].extend([
                "üîó √ânum√©ration des r√©pertoires : `gobuster dir -u http://[IP] -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt`",
                "üîó Scan des vuln√©rabilit√©s web : `nikto -h [IP]`",
                "üîó Test des sous-domaines : `wfuzz -c -w /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -u http://[IP] -H 'Host: FUZZ.[domain]'`"
            ])
            
        return recommendations

    @commands.command(name="scan")
    async def scan_target(self, ctx, scan_type: str, target: str, scan_mode: str = "basic"):
        """Scan a target using various tools
        
        Usage: 
        !scan ip [IP address] [scan_mode]  - Scan with Shodan
        !scan nmap [IP/domain] [scan_mode] - Scan with Nmap (basic/full/vuln)
        """
        # V√©rifier si la cible est valide
        if not await self.is_valid_target(target):
            await ctx.send("‚ùå Invalid target. Please provide a valid IP address or domain name.")
            return
            
        # Create embed for response
        embed = discord.Embed(
            title=f"üîç Scan Results: {target}",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        
        # Send initial message
        message = await ctx.send(f"üîç Scanning {target}... This may take a moment.")
        
        try:
            if scan_type.lower() == "ip":
                # Scan Shodan
                if not self.shodan_api:
                    await message.edit(content="‚ùå Shodan API key is not configured. Please contact the bot administrator.")
                    return
                    
                host_info = self.shodan_api.host(target)
                
                # Update embed with Shodan information
                embed.description = f"‚úÖ Shodan scan complete for {target}"
                
                # Add basic host information
                if 'country_name' in host_info:
                    embed.add_field(
                        name="üìç Location",
                        value=f"{host_info.get('country_name', 'Unknown')}, {host_info.get('city', 'Unknown')}",
                        inline=True
                    )
                    
                if 'org' in host_info:
                    embed.add_field(
                        name="üè¢ Organization",
                        value=host_info.get('org', 'Unknown'),
                        inline=True
                    )
                    
                if 'os' in host_info:
                    embed.add_field(
                        name="üíª Operating System",
                        value=host_info.get('os', 'Unknown'),
                        inline=True
                    )
                    
                # Add open ports from Shodan
                if 'ports' in host_info and host_info['ports']:
                    embed.add_field(
                        name="üîì Open Ports (Shodan)",
                        value=", ".join(map(str, host_info['ports'][:15])) + (f" and {len(host_info['ports']) - 15} more..." if len(host_info['ports']) > 15 else ""),
                        inline=False
                    )
                
            elif scan_type.lower() == "nmap":
                # Update message
                await message.edit(content=f"üîç Running Nmap scan on {target} ({scan_mode} mode)... This may take a while.")
                
                # Run Nmap scan
                scanner = await self.run_nmap_scan(target, scan_mode)
                
                if scanner and target in scanner.all_hosts():
                    host = scanner[target]
                    
                    # Basic host info
                    if 'hostnames' in host:
                        hostnames = ", ".join([h['name'] for h in host['hostnames']])
                        if hostnames:
                            embed.add_field(
                                name="üìõ Hostnames",
                                value=hostnames,
                                inline=False
                            )
                    
                    # OS detection
                    if 'osmatch' in host:
                        os_matches = host['osmatch']
                        if os_matches:
                            best_match = os_matches[0]
                            embed.add_field(
                                name="üíª Operating System",
                                value=f"{best_match['name']} ({best_match['accuracy']}% accuracy)",
                                inline=False
                            )
                    
                    # Port information with recommendations
                    open_ports = []
                    services_info = ""
                    security_recommendations = ""
                    exploits_found = ""
                    
                    if 'tcp' in host:
                        for port, data in host['tcp'].items():
                            if data['state'] == 'open':
                                open_ports.append(str(port))
                                
                                # Service info
                                service_info = f"**Port {port}** ({data['name']})\n"
                                if 'product' in data:
                                    service_info += f"Product: {data['product']}\n"
                                if 'version' in data:
                                    service_info += f"Version: {data['version']}\n"
                                services_info += service_info + "\n"
                                
                                # Get recommendations and exploits
                                recs = await self.get_service_recommendations(port, data)
                                
                                # Add security recommendations
                                if recs["risks"] or recs["recommendations"]:
                                    security_recommendations += f"\n**Port {port} ({data['name']}):**\n"
                                    if recs["risks"]:
                                        security_recommendations += "**Risques d√©tect√©s:**\n"
                                        security_recommendations += "\n".join(recs["risks"]) + "\n"
                                    if recs["recommendations"]:
                                        security_recommendations += "**Recommandations:**\n"
                                        security_recommendations += "\n".join(recs["recommendations"]) + "\n"
                                
                                # Add exploits if found
                                if recs["exploits"]:
                                    exploits_found += f"\n**üéØ Exploits pour {data['name']} ({data.get('product', '')} {data.get('version', '')}):**\n"
                                    for exploit in recs["exploits"][:3]:  # Limit to 3 exploits per service
                                        exploits_found += f"‚Ä¢ {exploit['title']}\n"
                                        exploits_found += f"  Type: {exploit['type']} | Platform: {exploit['platform']} | Date: {exploit['date']}\n"
                                        exploits_found += f"  üîó [Voir sur Exploit-DB](https://www.exploit-db.com/exploits/{exploit['id']})\n\n"
                    
                    if open_ports:
                        embed.add_field(
                            name="üîì Open Ports (Nmap)",
                            value=", ".join(open_ports),
                            inline=False
                        )
                    
                    if services_info:
                        embed.add_field(
                            name="üîß Services Detected",
                            value=services_info[:1024],
                            inline=False
                        )
                    
                    if exploits_found:
                        # Split exploits into chunks of 1024 characters
                        chunks = [exploits_found[i:i + 1024] for i in range(0, len(exploits_found), 1024)]
                        for i, chunk in enumerate(chunks):
                            embed.add_field(
                                name=f"üí• Available Exploits (Part {i+1})" if i > 0 else "üí• Available Exploits",
                                value=chunk,
                                inline=False
                            )
                    
                    if security_recommendations:
                        # Split recommendations into chunks of 1024 characters
                        chunks = [security_recommendations[i:i + 1024] for i in range(0, len(security_recommendations), 1024)]
                        for i, chunk in enumerate(chunks):
                            embed.add_field(
                                name=f"üõ°Ô∏è Security Recommendations (Part {i+1})" if i > 0 else "üõ°Ô∏è Security Recommendations",
                                value=chunk,
                                inline=False
                            )
                    
                    if exploits_found or security_recommendations:
                        embed.color = discord.Color.red()
                    
                    embed.description = f"‚úÖ Nmap scan complete for {target} ({scan_mode} mode)"
                else:
                    embed.description = f"‚ùå No results from Nmap scan for {target}"
            
            else:
                await message.edit(content="‚ùå Invalid scan type. Use 'ip' for Shodan scan or 'nmap' for Nmap scan.")
                return
            
        except Exception as e:
            embed.description = f"‚ùå Error occurred while scanning {target}: {str(e)}"
            embed.color = discord.Color.red()
        
        # Set footer
        embed.set_footer(text=f"Requested by {ctx.author.name}", icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
        
        # Edit the initial message with the embed
        await message.edit(content=None, embed=embed)

    async def analyze_file(self, file_url: str, filename: str) -> dict:
        """Analyze a file using VirusTotal API"""
        if not self.virustotal_api_key:
            return {"error": "VirusTotal API key not configured"}
            
        try:
            # Download the file
            async with aiohttp.ClientSession() as session:
                async with session.get(file_url) as response:
                    if response.status != 200:
                        return {"error": "Failed to download file"}
                    file_content = await response.read()
            
            # Calculate SHA256 hash
            sha256_hash = hashlib.sha256(file_content).hexdigest()
            
            # Check if the file has been previously scanned
            headers = {
                "accept": "application/json",
                "x-apikey": self.virustotal_api_key
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(f"https://www.virustotal.com/api/v3/files/{sha256_hash}", headers=headers) as response:
                    if response.status == 200:
                        result = await response.json()
                        return {
                            "found": True,
                            "data": result.get("data", {}),
                            "sha256": sha256_hash
                        }
                    elif response.status == 404:
                        # File hasn't been scanned before, upload it
                        url = "https://www.virustotal.com/api/v3/files"
                        
                        # Get upload URL
                        async with session.get("https://www.virustotal.com/api/v3/files/upload_url", headers=headers) as response:
                            if response.status != 200:
                                return {"error": "Failed to get upload URL"}
                            upload_url = (await response.json())["data"]
                        
                        # Upload file
                        files = {"file": (filename, file_content)}
                        async with session.post(upload_url, headers=headers, data=files) as response:
                            if response.status != 200:
                                return {"error": "Failed to upload file"}
                            upload_result = await response.json()
                            
                        # Get analysis results
                        analysis_id = upload_result["data"]["id"]
                        max_attempts = 10
                        attempts = 0
                        
                        while attempts < max_attempts:
                            async with session.get(f"https://www.virustotal.com/api/v3/analyses/{analysis_id}", headers=headers) as response:
                                if response.status == 200:
                                    result = await response.json()
                                    if result["data"]["attributes"]["status"] == "completed":
                                        return {
                                            "found": True,
                                            "data": result["data"],
                                            "sha256": sha256_hash
                                        }
                            attempts += 1
                            await asyncio.sleep(15)  # Wait between attempts
                            
                        return {"error": "Analysis timed out"}
                    else:
                        return {"error": f"VirusTotal API error: {response.status}"}
                        
        except Exception as e:
            return {"error": f"Error analyzing file: {str(e)}"}

    @commands.Cog.listener()
    async def on_message(self, message):
        """Listen for file attachments and analyze them"""
        if message.author.bot:
            return
            
        if not message.attachments:
            return
            
        for attachment in message.attachments:
            # Skip non-suspicious file types
            if any(attachment.filename.lower().endswith(ext) for ext in ['.jpg', '.png', '.gif', '.mp4', '.mp3', '.wav']):
                continue
                
            # Analyze the file
            loading_msg = await message.channel.send(f"üîç Analyzing file: {attachment.filename}...")
            
            result = await self.analyze_file(attachment.url, attachment.filename)
            
            if "error" in result:
                await loading_msg.edit(content=f"‚ùå Error analyzing file: {result['error']}")
                continue
                
            # Create embed for results
            embed = discord.Embed(
                title=f"üîç File Analysis: {attachment.filename}",
                color=discord.Color.blue(),
                timestamp=datetime.now()
            )
            
            if result["found"]:
                data = result["data"]
                attributes = data.get("attributes", {})
                stats = attributes.get("stats", {})
                
                # Add basic info
                embed.add_field(
                    name="üìä Analysis Results",
                    value=f"Malicious: {stats.get('malicious', 0)}\n"
                          f"Suspicious: {stats.get('suspicious', 0)}\n"
                          f"Harmless: {stats.get('harmless', 0)}",
                    inline=False
                )
                
                embed.add_field(
                    name="üîí File Hash (SHA256)",
                    value=f"`{result['sha256']}`",
                    inline=False
                )
                
                # Add link to full report
                embed.add_field(
                    name="üìù Full Report",
                    value=f"[View on VirusTotal](https://www.virustotal.com/gui/file/{result['sha256']})",
                    inline=False
                )
                
                # Set color based on results
                if stats.get('malicious', 0) > 0:
                    embed.color = discord.Color.red()
                    
                    # Send alert to dedicated channel if file is malicious
                    if self.alert_channel_id:
                        alert_channel = self.bot.get_channel(self.alert_channel_id)
                        if alert_channel:
                            alert_embed = discord.Embed(
                                title="‚ö†Ô∏è Malicious File Detected!",
                                description=f"A malicious file was uploaded in {message.channel.mention}",
                                color=discord.Color.red(),
                                timestamp=datetime.now()
                            )
                            alert_embed.add_field(
                                name="File Information",
                                value=f"Name: {attachment.filename}\n"
                                      f"Uploader: {message.author.mention}\n"
                                      f"Detections: {stats.get('malicious', 0)} / {sum(stats.values())}",
                                inline=False
                            )
                            await alert_channel.send(embed=alert_embed)
                elif stats.get('suspicious', 0) > 0:
                    embed.color = discord.Color.orange()
                else:
                    embed.color = discord.Color.green()
            
            # Set footer
            embed.set_footer(text=f"Requested by {message.author.name}", icon_url=message.author.avatar.url if message.author.avatar else None)
            
            # Edit the loading message with results
            await loading_msg.edit(content=None, embed=embed)

    async def monitor_new_cves(self):
        """Monitor for new critical CVEs"""
        await self.bot.wait_until_ready()
        
        # Get alert channel
        if not self.alert_channel_id:
            print("No alert channel configured for CVE monitoring")
            return
            
        alert_channel = self.bot.get_channel(self.alert_channel_id)
        if not alert_channel:
            print(f"Could not find alert channel with ID {self.alert_channel_id}")
            return
            
        # Send initial message with last 5 critical CVEs
        try:
            # Get CVEs from the last 7 days
            current_time = datetime.now()
            start_date = (current_time - timedelta(days=7)).strftime("%Y-%m-%dT%H:00:00.000")
            
            url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            params = {
                "pubStartDate": start_date,
                "cvssV3Severity": "CRITICAL",  # Only get critical vulnerabilities
                "resultsPerPage": 5  # Limit to 5 results
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        if data.get("vulnerabilities"):
                            await alert_channel.send("üîç **Derni√®res CVE critiques d√©tect√©es :**")
                            
                            # Store the IDs of CVEs we've seen
                            self.seen_cves = set()
                            
                            for vuln in data["vulnerabilities"]:
                                cve = vuln["cve"]
                                cve_id = cve.get('id')
                                self.seen_cves.add(cve_id)
                                
                                # Create embed for the CVE
                                embed = discord.Embed(
                                    title=f"‚ö†Ô∏è CVE Critique : {cve_id}",
                                    color=discord.Color.red(),
                                    timestamp=datetime.now()
                                )
                                
                                # Add description
                                if "descriptions" in cve:
                                    for desc in cve["descriptions"]:
                                        if desc["lang"] == "en":
                                            embed.description = desc["value"]
                                            break
                                
                                # Add CVSS score
                                if "metrics" in cve and "cvssMetricV31" in cve["metrics"]:
                                    cvss = cve["metrics"]["cvssMetricV31"][0]["cvssData"]
                                    embed.add_field(
                                        name="‚ö†Ô∏è CVSS Score",
                                        value=f"{cvss.get('baseScore', 'N/A')} ({cvss.get('baseSeverity', 'Unknown')})",
                                        inline=True
                                    )
                                
                                # Add references
                                if "references" in cve:
                                    refs = "\n".join([f"‚Ä¢ [{ref.get('source')}]({ref.get('url')})" for ref in cve["references"][:5]])
                                    if refs:
                                        embed.add_field(
                                            name="üìö References",
                                            value=refs,
                                            inline=False
                                        )
                                
                                # Add NVD link
                                embed.add_field(
                                    name="üîó More Information",
                                    value=f"[View on NVD](https://nvd.nist.gov/vuln/detail/{cve_id})",
                                    inline=False
                                )
                                
                                await alert_channel.send(embed=embed)
                            
                            await alert_channel.send("‚ö° La surveillance des nouvelles CVE est maintenant active. Je vous alerterai d√®s qu'une nouvelle CVE critique sera publi√©e.")
        
        except Exception as e:
            print(f"Error fetching initial CVEs: {str(e)}")
        
        # Start monitoring loop
        while not self.bot.is_closed():
            try:
                # Get current time
                current_time = datetime.now()
                
                # Check for new CVEs every hour
                if not self.last_cve_check or (current_time - self.last_cve_check).total_seconds() > 3600:
                    # Get CVEs from the last hour
                    start_date = (current_time - timedelta(hours=1)).strftime("%Y-%m-%dT%H:00:00.000")
                    
                    # Query NVD API
                    url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
                    params = {
                        "pubStartDate": start_date,
                        "cvssV3Severity": "CRITICAL"  # Only get critical vulnerabilities
                    }
                    
                    async with aiohttp.ClientSession() as session:
                        async with session.get(url, params=params) as response:
                            if response.status == 200:
                                data = await response.json()
                                
                                if data.get("vulnerabilities"):
                                    for vuln in data["vulnerabilities"]:
                                        cve = vuln["cve"]
                                        cve_id = cve.get('id')
                                        
                                        # Only alert for CVEs we haven't seen before
                                        if cve_id not in self.seen_cves:
                                            self.seen_cves.add(cve_id)
                                            
                                            # Create embed for the CVE
                                            embed = discord.Embed(
                                                title=f"‚ö†Ô∏è Nouvelle CVE Critique D√©tect√©e : {cve_id}",
                                                color=discord.Color.red(),
                                                timestamp=datetime.now()
                                            )
                                            
                                            # Add description
                                            if "descriptions" in cve:
                                                for desc in cve["descriptions"]:
                                                    if desc["lang"] == "en":
                                                        embed.description = desc["value"]
                                                        break
                                            
                                            # Add CVSS score
                                            if "metrics" in cve and "cvssMetricV31" in cve["metrics"]:
                                                cvss = cve["metrics"]["cvssMetricV31"][0]["cvssData"]
                                                embed.add_field(
                                                    name="‚ö†Ô∏è CVSS Score",
                                                    value=f"{cvss.get('baseScore', 'N/A')} ({cvss.get('baseSeverity', 'Unknown')})",
                                                    inline=True
                                                )
                                            
                                            # Add references
                                            if "references" in cve:
                                                refs = "\n".join([f"‚Ä¢ [{ref.get('source')}]({ref.get('url')})" for ref in cve["references"][:5]])
                                                if refs:
                                                    embed.add_field(
                                                        name="üìö References",
                                                        value=refs,
                                                        inline=False
                                                    )
                                            
                                            # Add NVD link
                                            embed.add_field(
                                                name="üîó More Information",
                                                value=f"[View on NVD](https://nvd.nist.gov/vuln/detail/{cve_id})",
                                                inline=False
                                            )
                                            
                                            # Send alert
                                            await alert_channel.send(
                                                content="@everyone ‚ö†Ô∏è Nouvelle vuln√©rabilit√© critique d√©tect√©e !",
                                                embed=embed
                                            )
                    
                    self.last_cve_check = current_time
            
            except Exception as e:
                print(f"Error monitoring CVEs: {str(e)}")
            
            # Wait for 1 hour before next check
            await asyncio.sleep(3600)

    def cog_unload(self):
        """Clean up tasks when cog is unloaded"""
        if hasattr(self, 'cve_monitor_task'):
            self.cve_monitor_task.cancel()

    async def get_ipinfo_data(self, ip: str) -> dict:
        """Get information about an IP address from IPinfo.io API"""
        if not self.ipinfo_api_key:
            return {"error": "IPinfo API key not configured"}
            
        try:
            url = f"https://ipinfo.io/{ip}/json?token={self.ipinfo_api_key}"
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as response:
                    if response.status == 200:
                        return await response.json()
                    else:
                        return {"error": f"IPinfo API error: {response.status}"}
        except Exception as e:
            return {"error": f"Error retrieving IP information: {str(e)}"}
            
    def detect_cloud_provider(self, org: str) -> str:
        """Detect if the organization is a cloud provider"""
        org_lower = org.lower()
        detected_providers = []
        
        for provider, keywords in self.cloud_providers.items():
            for keyword in keywords:
                if keyword.lower() in org_lower:
                    detected_providers.append(provider)
                    break
        
        if detected_providers:
            return ", ".join(detected_providers)
        return None
        
    def detect_vpn_proxy(self, org: str, hostname: str) -> bool:
        """Detect if the IP might be a VPN/Proxy/Tor node"""
        text_to_check = (org + " " + hostname).lower()
        
        for indicator in self.vpn_proxy_indicators:
            if indicator in text_to_check:
                return True
                
        return False
    
    @commands.command(name="ipinfo")
    async def ip_info(self, ctx, ip: str):
        """Get detailed information about an IP address using IPinfo.io
        
        Usage: !ipinfo [IP address]
        Example: !ipinfo 8.8.8.8
        """
        # Validate IP address format
        try:
            ipaddress.ip_address(ip)
        except ValueError:
            await ctx.send("‚ùå Invalid IP address format. Please provide a valid IPv4 or IPv6 address.")
            return
        
        # Create embed for response
        embed = discord.Embed(
            title=f"üîç IP Information: {ip}",
            color=discord.Color.blue(),
            timestamp=datetime.now()
        )
        
        # Send initial message
        message = await ctx.send(f"üîç Looking up information for {ip}... Please wait.")
        
        try:
            # Get IP information from IPinfo
            ipinfo_data = await self.get_ipinfo_data(ip)
            
            if "error" in ipinfo_data:
                embed.description = f"‚ùå {ipinfo_data['error']}"
                embed.color = discord.Color.red()
            else:
                embed.description = f"‚úÖ IP information for {ip}"
                
                # Add location information
                location_parts = []
                if "city" in ipinfo_data:
                    location_parts.append(ipinfo_data["city"])
                if "region" in ipinfo_data:
                    location_parts.append(ipinfo_data["region"])
                if "country" in ipinfo_data:
                    location_parts.append(ipinfo_data["country"])
                
                if location_parts:
                    embed.add_field(
                        name="üìç Location",
                        value=", ".join(location_parts),
                        inline=True
                    )
                
                # Add network information
                if "org" in ipinfo_data:
                    embed.add_field(
                        name="üè¢ Organization",
                        value=ipinfo_data["org"],
                        inline=True
                    )
                
                if "hostname" in ipinfo_data:
                    embed.add_field(
                        name="üåê Hostname",
                        value=ipinfo_data["hostname"],
                        inline=True
                    )
                
                # Add ASN information
                if "asn" in ipinfo_data:
                    embed.add_field(
                        name="üî¢ ASN",
                        value=ipinfo_data["asn"],
                        inline=True
                    )
                
                # Add ISP information
                if "org" in ipinfo_data:
                    embed.add_field(
                        name="üåê ISP",
                        value=ipinfo_data["org"],
                        inline=True
                    )
                
                # Check for cloud provider
                if "org" in ipinfo_data:
                    cloud_provider = self.detect_cloud_provider(ipinfo_data["org"])
                    if cloud_provider:
                        embed.add_field(
                            name="‚òÅÔ∏è Cloud Provider",
                            value=cloud_provider,
                            inline=True
                        )
                
                # Check for VPN/Proxy
                if "org" in ipinfo_data and "hostname" in ipinfo_data:
                    is_vpn_proxy = self.detect_vpn_proxy(
                        ipinfo_data["org"], 
                        ipinfo_data.get("hostname", "")
                    )
                    if is_vpn_proxy:
                        embed.add_field(
                            name="üè¥ VPN/Proxy Detection",
                            value="‚ö†Ô∏è This IP appears to be a VPN, Proxy, or Tor exit node",
                            inline=False
                        )
                        embed.color = discord.Color.orange()
                
                # Add abuse contact
                if "abuse" in ipinfo_data:
                    abuse_info = []
                    if "email" in ipinfo_data["abuse"]:
                        abuse_info.append(f"Email: {ipinfo_data['abuse']['email']}")
                    if "phone" in ipinfo_data["abuse"]:
                        abuse_info.append(f"Phone: {ipinfo_data['abuse']['phone']}")
                    
                    if abuse_info:
                        embed.add_field(
                            name="üìß Abuse Contact",
                            value="\n".join(abuse_info),
                            inline=False
                        )
                
                # Add threat intelligence section with option to run more scans
                embed.add_field(
                    name="üîí Threat Intelligence",
                    value="Use `!scan nmap " + ip + " [mode]` to scan for open ports and vulnerabilities\n"
                         "Use `!scan ip " + ip + "` to get information from Shodan",
                    inline=False
                )
            
        except Exception as e:
            embed.description = f"‚ùå Error occurred while retrieving information for {ip}: {str(e)}"
            embed.color = discord.Color.red()
        
        # Set footer
        embed.set_footer(text=f"Requested by {ctx.author.name}", icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
        
        # Edit the initial message with the embed
        await message.edit(content=None, embed=embed)

async def setup(bot):
    await bot.add_cog(Exploiter(bot)) 